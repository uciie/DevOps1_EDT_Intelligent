\documentclass[12pt,a4paper]{report}
\usepackage[utf8]{inputenc}
\usepackage[french]{babel}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{geometry}
\usepackage{color}
\geometry{margin=2.5cm}

% Definir le chemin de base pour les graphiques
\graphicspath{{./}{uml/}}

% Configuration pour le code Java
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=Java,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=left,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}

\title{Dossier Technique \& Manuel Utilisateur \\ \Large Projet DevOps - DevOps1\_EDT\_Intelligent}
\author{Equipe EDT Intelligent \\ Universite Paris Nanterre}
\date{\today}

\begin{document}

\maketitle
\tableofcontents

\chapter{Introduction}
Ce document presente l'application \textbf{DevOps1\_EDT\_Intelligent}, un systeme de gestion d'emploi du temps intelligent. Il detaille l'architecture technique, les processus DevOps mis en place et le guide d'utilisation, en s'appuyant sur les standards de qualite logicielle. L'objectif principal est de fournir une plateforme centralisee permettant de gerer ses taches, son emploi du temps, et d'optimiser ses periodes de travail grace a l'intelligence artificielle et l'analyse de donnees.

\chapter{Architecture Technique}

\section{Diagramme de Classes UML}
Le diagramme suivant represente la structure globale du backend de l'application. Il est genere automatiquement a chaque modification du code Java.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.8\textwidth]{diagram_classes.png}
    \caption{Diagramme de classes automatique}
\end{figure}

\section{Technologies Utilisees}
\begin{itemize}
    \item \textbf{Backend :} Java 21 avec Spring Boot 3.
    \item \textbf{Frontend :} React / Vite avec Tailwind CSS.
    \item \textbf{Base de donnees :} PostgreSQL (H2 pour les tests).
    \item \textbf{Build :} Gradle.
    \item \textbf{CI/CD :} GitHub Actions.
    \item \textbf{IA :} Google Gemini API.
\end{itemize}

\section{Integration Continue (CI)}
Plusieurs workflows GitHub Actions assurent la stabilite du projet :
\begin{itemize}
    \item \textbf{Build \& Test :} Compilation et execution des tests unitaires a chaque push.
    \item \textbf{Analyse de Qualite :} Utilisation de SonarCloud pour detecter les vulnerabilites et la dette technique.
    \item \textbf{Couverture de Code :} Generation de rapports Jacoco avec un seuil minimal de 60\%.
    \item \textbf{Generation Doc :} Mise a jour automatique des diagrammes UML et de la documentation PDF.
\end{itemize}

\section{Generation UML Automatique}
A chaque modification dans \texttt{backend/src/main/java}, un workflow specifique s'execute :
\begin{enumerate}
    \item Une tache Gradle (\texttt{generatePlantUml}) execute un utilitaire Java qui scanne les classes et genere le fichier \texttt{diagram\_classes.puml}.
    \item PlantUML convertit tous les fichiers \texttt{.puml} du dossier \texttt{doc/uml/} en images \texttt{.png}.
    \item Les changements sont automatiquement "commit" et "push" sur la branche de documentation.
\end{enumerate}

\chapter{Manuel Utilisateur}

\section{Prerequis et Configuration}
Avant de proceder a l'installation, assurez-vous que les elements suivants sont configures sur votre machine :
\begin{itemize}
    \item \textbf{Java Development Kit (JDK) 21 :} Indispensable pour compiler et executer le backend.
    \item \textbf{Node.js (version 18+) et npm :} Requis pour le frontend.
    \item \textbf{Variables d'environnement :} Creez un fichier \texttt{.env} dans \texttt{backend/} avec les cles \texttt{DB\_URL}, \texttt{DB\_USER}, \texttt{DB\_PASSWORD} et \texttt{GOOGLE\_API\_KEY}.
\end{itemize}

\section{Installation et Lancement}
\begin{enumerate}
    \item \textbf{Clonage :} \texttt{git clone https://github.com/uciie/DevOps1\_EDT\_Intelligent.git}.
    \item \textbf{Backend :} 
    \begin{itemize}
        \item \texttt{cd backend}
        \item \texttt{./gradlew bootRun}
    \end{itemize}
    \item \textbf{Frontend :}
    \begin{itemize}
        \item \texttt{cd frontend}
        \item \texttt{npm install}
        \item \texttt{npm run dev}
    \end{itemize}
\end{enumerate}

\chapter{Fonctionnalites Detaillees \& Implementation}

\section{Gestion des Taches}
Le systeme permet une gestion granulaire des taches individuelles ou d'equipe.
\subsection{Implementation}
Les extraits de code source sont disponibles dans le depot GitHub. La classe \texttt{TaskServiceImpl} implemente la logique metier pour la creation, modification et suppression des taches.

\subsection{Diagramme de sequence}
\begin{figure}[h]
    \centering
    \includegraphics[width=0.8\textwidth]{sequence_task_lifecycle.png}
    \caption{Cycle de vie d'une tache}
\end{figure}

\section{Optimisation de l'Emploi du Temps}
Cette fonctionnalite planifie des sessions de travail en fonction des trous dans l'agenda.
\subsection{Algorithme de selection}
La strategie de selection par defaut priorise les taches selon leur deadline et leur importance. Le code source est disponible dans \texttt{DefaultTaskSelectionStrategy.java}.

\subsection{Diagramme de sequence}
\begin{figure}[h]
    \centering
    \includegraphics[width=0.8\textwidth]{sequence_ScheduleOptimizer.png}
    \caption{Optimisation intelligente du planning}
\end{figure}

\section{Calcul des Temps de Trajet}
Le systeme calcule automatiquement le temps necessaire pour se rendre d'un evenement a un autre.
\subsection{Implementation}
Le calculateur de trajet simple estime le temps de deplacement entre deux localisations. Pour plus de details, consultez \texttt{SimpleTravelTimeCalculator.java}.

\subsection{Diagramme de sequence}
\begin{figure}[h]
    \centering
    \includegraphics[width=0.8\textwidth]{sequence_TempsTrajet.png}
    \caption{Processus de calcul des temps de trajet}
\end{figure}

\section{Chatbot Assistant (Gemini AI)}
Un assistant virtuel repond aux questions sur le planning via le langage naturel.
\subsection{Fonctionnement}
L'assistant utilise l'API Google Gemini et recoit le contexte de l'utilisateur (evenements et taches).
\subsection{Diagramme de sequence}
\begin{figure}[h]
    \centering
    \includegraphics[width=0.8\textwidth]{sequence_Chatbot.png}
    \caption{Interaction avec l'assistant IA}
\end{figure}

\section{Mode Focus et Productivite}
Le mode Focus aide a identifier les meilleures periodes de concentration.
\subsection{Implementation FocusService}
Le service Focus analyse les preferences utilisateur et suggere des creneaux optimaux. Consultez \texttt{FocusService.java} pour l'implementation complete.

\section{Import d'Agenda (ICS)}
L'utilisateur peut importer ses calendriers ADE ou Google Calendar via des fichiers .ics.
\subsection{Implementation Service}
Le service d'import parse les fichiers ICS et synchronise les evenements. La logique est implementee dans \texttt{CalendarImportService.java}.

\subsection{Diagramme de sequence}
\begin{figure}[h]
    \centering
    \includegraphics[width=0.8\textwidth]{sequence_ImportAgenda.png}
    \caption{Importation d'evenements externes}
\end{figure}

\section{Gestion d'Equipe et Collaboration}
Permet de partager des taches et d'inviter des membres dans une equipe.
\subsection{Diagramme de sequence}
\begin{figure}[h]
    \centering
    \includegraphics[width=0.8\textwidth]{sequence_CollabTeam.png}
    \caption{Flux d'invitation d'equipe}
\end{figure}

\chapter{Tests et Qualite Logicielle}
Le projet suit une approche de developpement pilote par les tests (TDD).

\section{Tests Unitaires et Mockito}
Tous les services critiques disposent de tests unitaires utilisant JUnit 5 et Mockito. Les tests sont disponibles dans le package \texttt{src/test/java}.

\section{Couverture de Code}
Le rapport Jacoco est genere a chaque build. Nous visons une couverture d'au moins 60\% sur les services critiques.

\chapter{Conclusion}
L'application \textbf{DevOps1\_EDT\_Intelligent} repond au besoin croissant d'organisation personnelle et collective. L'automatisation des processus DevOps assure une haute qualite logicielle.

\end{document}